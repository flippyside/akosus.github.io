<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="# basic

## history of intel processors and architectures

Intel X86 Processors：

- dominate laptop/desktop/server market
- CISC(complex instruction set computer)
- evolution
  - 8086: 16-bit
  - 386(i386)(80386)(IA32) 32-bit
  - pentium4E(x86-64): 64-bit
  - core 2: multi-core
  - core i7: four cores

Architecture(ISA: instruction set architecture): the parts of a processor design that needs to understand or write assembly/machine code

machine code: byte-level programs, can be executed by processor
assembly code: a text representation of machine code

programmer-visible state:

- PC: program counter
  - address of next instruction
  - RIP in x86-64
- Register File: heavily used program data
- Condition Codes:
  - store status information about most
  - used for conditional branching
- Memory
  - byte addressable array
  - code and user data
  - stack to support procedures

```c
long plus(long x, long y);
void sumstore(long x, long y, long *dest){
    long t = plus(x, y);
    *dest = t;
}
```

```asm
sumstore:
  pushq %rbx
  movq %rdx, %rbx
  call plus
  movq %rax, (%rbx)
  popq %rbx
  ret
```

## assembly characteristics

Data type:

- integer data of 1,2,4, 8 byte
- floating point data of 4, 8, 10 byte
- code: byte sequences encoding series of instructions
- no aggregate types such as arrays or structures

Operation:

- perform arithmetic function on register or memory data
- transfer data between memory and register
- transfer control

```
# C code
*dest = t;

# Assembly
movq %rax, (%rbx) # move 8-byte value to memory
# operands:
#  t:     register %rax
#  dest:  register %rbx
#  *dest:  memory  M[%rbx]

# object code
0x40059e: 48 89 03
# 3-byte instuction
# stored at address 0x40059e
```

![Alt text](assets/ch3/image-1.png)

```
%r: 64bit
%e: 32bit
```

x8664将寄存器增加到%r，相比i386增加了一倍

![Alt text](assets/ch3/image-2.png)

寄存器的名字在很早之前反映了他们的特定功能，现在没有这种对应了。">
<meta property="og:title" content="machine-level-programming[CSAPP]">
<meta property="og:description" content="# basic

## history of intel processors and architectures

Intel X86 Processors：

- dominate laptop/desktop/server market
- CISC(complex instruction set computer)
- evolution
  - 8086: 16-bit
  - 386(i386)(80386)(IA32) 32-bit
  - pentium4E(x86-64): 64-bit
  - core 2: multi-core
  - core i7: four cores

Architecture(ISA: instruction set architecture): the parts of a processor design that needs to understand or write assembly/machine code

machine code: byte-level programs, can be executed by processor
assembly code: a text representation of machine code

programmer-visible state:

- PC: program counter
  - address of next instruction
  - RIP in x86-64
- Register File: heavily used program data
- Condition Codes:
  - store status information about most
  - used for conditional branching
- Memory
  - byte addressable array
  - code and user data
  - stack to support procedures

```c
long plus(long x, long y);
void sumstore(long x, long y, long *dest){
    long t = plus(x, y);
    *dest = t;
}
```

```asm
sumstore:
  pushq %rbx
  movq %rdx, %rbx
  call plus
  movq %rax, (%rbx)
  popq %rbx
  ret
```

## assembly characteristics

Data type:

- integer data of 1,2,4, 8 byte
- floating point data of 4, 8, 10 byte
- code: byte sequences encoding series of instructions
- no aggregate types such as arrays or structures

Operation:

- perform arithmetic function on register or memory data
- transfer data between memory and register
- transfer control

```
# C code
*dest = t;

# Assembly
movq %rax, (%rbx) # move 8-byte value to memory
# operands:
#  t:     register %rax
#  dest:  register %rbx
#  *dest:  memory  M[%rbx]

# object code
0x40059e: 48 89 03
# 3-byte instuction
# stored at address 0x40059e
```

![Alt text](assets/ch3/image-1.png)

```
%r: 64bit
%e: 32bit
```

x8664将寄存器增加到%r，相比i386增加了一倍

![Alt text](assets/ch3/image-2.png)

寄存器的名字在很早之前反映了他们的特定功能，现在没有这种对应了。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://flippyside.github.io/akosus.github.io/post/machine-level-programming%5BCSAPP%5D.html">
<meta property="og:image" content="https://github.githubassets.com/favicons/favicon.svg">
<title>machine-level-programming[CSAPP]</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">machine-level-programming[CSAPP]</h1>
<div class="title-right">
    <a href="https://flippyside.github.io/akosus.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/flippyside/akosus.github.io/issues/1" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1>basic</h1>
<h2>history of intel processors and architectures</h2>
<p>Intel X86 Processors：</p>
<ul>
<li>dominate laptop/desktop/server market</li>
<li>CISC(complex instruction set computer)</li>
<li>evolution
<ul>
<li>8086: 16-bit</li>
<li>386(i386)(80386)(IA32) 32-bit</li>
<li>pentium4E(x86-64): 64-bit</li>
<li>core 2: multi-core</li>
<li>core i7: four cores</li>
</ul>
</li>
</ul>
<p>Architecture(ISA: instruction set architecture): the parts of a processor design that needs to understand or write assembly/machine code</p>
<p>machine code: byte-level programs, can be executed by processor<br>
assembly code: a text representation of machine code</p>
<p>programmer-visible state:</p>
<ul>
<li>PC: program counter
<ul>
<li>address of next instruction</li>
<li>RIP in x86-64</li>
</ul>
</li>
<li>Register File: heavily used program data</li>
<li>Condition Codes:
<ul>
<li>store status information about most</li>
<li>used for conditional branching</li>
</ul>
</li>
<li>Memory
<ul>
<li>byte addressable array</li>
<li>code and user data</li>
<li>stack to support procedures</li>
</ul>
</li>
</ul>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">long</span> <span class="pl-en">plus</span>(<span class="pl-smi">long</span> <span class="pl-s1">x</span>, <span class="pl-smi">long</span> <span class="pl-s1">y</span>);
<span class="pl-smi">void</span> <span class="pl-en">sumstore</span>(<span class="pl-smi">long</span> <span class="pl-s1">x</span>, <span class="pl-smi">long</span> <span class="pl-s1">y</span>, <span class="pl-smi">long</span> <span class="pl-c1">*</span><span class="pl-s1">dest</span>){
    <span class="pl-smi">long</span> <span class="pl-s1">t</span> <span class="pl-c1">=</span> <span class="pl-en">plus</span>(<span class="pl-s1">x</span>, <span class="pl-s1">y</span>);
    <span class="pl-c1">*</span><span class="pl-s1">dest</span> <span class="pl-c1">=</span> <span class="pl-s1">t</span>;
}</pre></div>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">sumstore:</span>
<span class="pl-en">  pushq %</span><span class="pl-v">rbx</span>
<span class="pl-en">  </span><span class="pl-k">movq</span><span class="pl-en"> %</span><span class="pl-v">rdx</span><span class="pl-s1">,</span><span class="pl-en"> %</span><span class="pl-v">rbx</span>
<span class="pl-en">  </span><span class="pl-k">call</span><span class="pl-en"> plus</span>
<span class="pl-en">  </span><span class="pl-k">movq</span><span class="pl-en"> %</span><span class="pl-v">rax</span><span class="pl-s1">,</span><span class="pl-en"> (%</span><span class="pl-v">rbx</span><span class="pl-en">)</span>
<span class="pl-en">  popq %</span><span class="pl-v">rbx</span>
<span class="pl-en">  </span><span class="pl-k">ret</span></pre></div>
<h2>assembly characteristics</h2>
<p>Data type:</p>
<ul>
<li>integer data of 1,2,4, 8 byte</li>
<li>floating point data of 4, 8, 10 byte</li>
<li>code: byte sequences encoding series of instructions</li>
<li>no aggregate types such as arrays or structures</li>
</ul>
<p>Operation:</p>
<ul>
<li>perform arithmetic function on register or memory data</li>
<li>transfer data between memory and register</li>
<li>transfer control</li>
</ul>
<pre class="notranslate"><code class="notranslate"># C code
*dest = t;

# Assembly
movq %rax, (%rbx) # move 8-byte value to memory
# operands:
#  t:     register %rax
#  dest:  register %rbx
#  *dest:  memory  M[%rbx]

# object code
0x40059e: 48 89 03
# 3-byte instuction
# stored at address 0x40059e
</code></pre>
<p><a target="_blank" rel="noopener noreferrer" href="assets/ch3/image-1.png"><img src="assets/ch3/image-1.png" alt="Alt text" style="max-width: 100%;"></a></p>
<pre class="notranslate"><code class="notranslate">%r: 64bit
%e: 32bit
</code></pre>
<p>x8664将寄存器增加到%r，相比i386增加了一倍</p>
<p><a target="_blank" rel="noopener noreferrer" href="assets/ch3/image-2.png"><img src="assets/ch3/image-2.png" alt="Alt text" style="max-width: 100%;"></a></p>
<p>寄存器的名字在很早之前反映了他们的特定功能，现在没有这种对应了。除了esp之外：%esp: 栈指针</p>
<h1>访问信息</h1>
<h2>MOV</h2>
<pre class="notranslate"><code class="notranslate">movq Src Dest
</code></pre>
<p>DEST ← SRC;</p>
<ul>
<li>the SRC in movq only can be 32 bit. It sign-extend it to 64 bit, and put it into dest.</li>
<li><code class="notranslate">movabsq</code>(传送绝对的四字)'s SRC can be 64 bit.</li>
</ul>
<p>operand types:</p>
<ul>
<li>immediate(立即数): constant integer data
<ul>
<li>e.g. $0x400 $-533</li>
<li>encoded with 1, 2 or 4 bytes</li>
</ul>
</li>
<li>register(寄存器): one of 16 integer register
<ul>
<li>e.g. %rax %r13</li>
</ul>
</li>
<li>memory(内存引用): 8 consecutive bytes of memory at address given by register
<ul>
<li>e.g. (%rax)</li>
</ul>
</li>
</ul>
<p>movq 的所有可能组合：不能mem-mem</p>
<p><a target="_blank" rel="noopener noreferrer" href="assets/ch3/image-3.png"><img src="assets/ch3/image-3.png" alt="Alt text" style="max-width: 100%;"></a></p>
<p>simple memory addressing modes</p>
<ul>
<li>Normal: (R) <code class="notranslate">Mem[Reg[R]]</code>
<ul>
<li>register R specifies <strong>memory address</strong></li>
<li>pointer dereferencing in C</li>
</ul>
</li>
<li>Displacement(偏移值): D(R) <code class="notranslate">Mem[Reg[R]+D]</code>
<ul>
<li>register R specifies the <strong>start</strong> of memory region</li>
<li>constant displacement D specifies offset</li>
</ul>
</li>
</ul>
<p>examples for normal:</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">void</span> <span class="pl-en">swap</span>(<span class="pl-smi">long</span> <span class="pl-c1">*</span><span class="pl-s1">xp</span>, <span class="pl-smi">long</span> <span class="pl-c1">*</span><span class="pl-s1">yp</span>){
    <span class="pl-smi">long</span> <span class="pl-s1">t0</span> <span class="pl-c1">=</span> <span class="pl-c1">*</span><span class="pl-s1">xp</span>;
    <span class="pl-smi">long</span> <span class="pl-s1">t1</span> <span class="pl-c1">=</span> <span class="pl-c1">*</span><span class="pl-s1">yp</span>;
    <span class="pl-c1">*</span><span class="pl-s1">xp</span> <span class="pl-c1">=</span> <span class="pl-s1">t1</span>;
    <span class="pl-c1">*</span><span class="pl-s1">yp</span> <span class="pl-c1">=</span> <span class="pl-s1">t0</span>;
}</pre></div>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">swap:</span>
<span class="pl-en">    </span><span class="pl-k">movq</span><span class="pl-en"> (%</span><span class="pl-v">rdi</span><span class="pl-en">)</span><span class="pl-s1">,</span><span class="pl-en"> %</span><span class="pl-v">rax</span>
<span class="pl-en">    </span><span class="pl-k">movq</span><span class="pl-en"> (%</span><span class="pl-v">rsi</span><span class="pl-en">)</span><span class="pl-s1">,</span><span class="pl-en"> %</span><span class="pl-v">rdx</span>
<span class="pl-en">    </span><span class="pl-k">movq</span><span class="pl-en"> %</span><span class="pl-v">rdx</span><span class="pl-s1">,</span><span class="pl-en"> (%</span><span class="pl-v">rdi</span><span class="pl-en">)</span>
<span class="pl-en">    </span><span class="pl-k">movq</span><span class="pl-en"> %</span><span class="pl-v">rax</span><span class="pl-s1">,</span><span class="pl-en"> (%</span><span class="pl-v">rsi</span><span class="pl-en">)</span>
<span class="pl-en">    </span><span class="pl-k">ret</span></pre></div>
<p>rdi：xp，即指向存储【指针xp指向的值】的内存地址<br>
rsi：yp，即指向存储【指针yp指向的值】的内存地址<br>
rax：t0<br>
rdx：t1</p>
<p><a target="_blank" rel="noopener noreferrer" href="assets/lec5/image.png"><img src="assets/lec5/image.png" alt="Alt text" style="max-width: 100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="assets/lec5/image-1.png"><img src="assets/lec5/image-1.png" alt="Alt text" style="max-width: 100%;"></a><br>
<a target="_blank" rel="noopener noreferrer" href="assets/lec5/image-2.png"><img src="assets/lec5/image-2.png" alt="Alt text" style="max-width: 100%;"></a><br>
<a target="_blank" rel="noopener noreferrer" href="assets/lec5/image-3.png"><img src="assets/lec5/image-3.png" alt="Alt text" style="max-width: 100%;"></a></p>
<p>MOVZ &amp; MOVS:</p>
<ul>
<li>movz zero-extend DEST</li>
<li>movs sign-extend DEST</li>
</ul>
<pre class="notranslate"><code class="notranslate">movzbw SRC, DEST
</code></pre>
<h3>address computation</h3>
<p>存储器操作数形式：</p>
<p><code class="notranslate">偏移量(基址寄存器，变址寄存器，比例因子)</code></p>
<p><code class="notranslate">D(Rb, Ri, S)</code> -&gt; <code class="notranslate">Mem[Reg[Rb] + S * Reg[Ri] + D]</code><br>
D: constant displacement, 1,2,4 bytes<br>
Rb: base register, any of 16 integer registers<br>
Ri: index register, any, expect %rsp<br>
S: scale, 1,2,4,8</p>
<pre class="notranslate"><code class="notranslate">100   (%ebx,      %esi,     4)
偏移量 基址寄存器，变址寄存器，比例因子
</code></pre>
<p>address computation examples:</p>
<pre class="notranslate"><code class="notranslate">%rdx 0xf000
%rcx 0x0100

0x8(%rdx)   0xf000 + 0x8 = 0xf008
(%rdx, %rcx)   0xf000 + 0x100 = 0xf100
(%rdx, %rcx, 4)   0xf000 + 4 * 0x100 = 0xf400
0x80(, %rdx, 2)   2 * 0xf000 + 0x80 = 0x1e080
</code></pre>
<h3>pop&amp;push</h3>
<p>the address of the top of the stack is the <strong>LOWest</strong>. the stack pointer <strong>%rsp</strong> stores the address of the top.</p>
<pre class="notranslate"><code class="notranslate">pushq S
R[%rsp] &lt;- R[%rsp] - 8
M[R[%rsp]] &lt;- S

popq D
D &lt;- M[R[%rsp]]
R[%rsp] &lt;- R[%rsp] + 8
</code></pre>
<p>popq %rax is equal to:</p>
<pre class="notranslate"><code class="notranslate">movq (%rsp), %rax
addq $8, %rsp
</code></pre>
<h1>arithmetic &amp; logical operations</h1>
<p>there is one-operand and two-operand instr.</p>
<p>the 2-operand is just like <code class="notranslate">+=</code> <code class="notranslate">-=</code> in C.</p>
<h2>leaq(load effective address)</h2>
<pre class="notranslate"><code class="notranslate">leaq src, dst
</code></pre>
<ul>
<li>src is address mode expression, set dst to address denoted by expression.</li>
<li>that is, compute the address(x + k * y) and load it to the register</li>
</ul>
<p>e.g.</p>
<p>if rdi is x:</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">leaq </span><span class="pl-c1">7</span><span class="pl-en">(%</span><span class="pl-v">rdi</span><span class="pl-s1">,</span><span class="pl-en"> %</span><span class="pl-v">rdi</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">4</span><span class="pl-en">)</span><span class="pl-s1">,</span><span class="pl-en"> %</span><span class="pl-v">rax</span><span class="pl-en">    # set the %</span><span class="pl-v">rax</span><span class="pl-en"> to </span><span class="pl-c1">7</span><span class="pl-en"> </span><span class="pl-s1">+</span><span class="pl-en"> x </span><span class="pl-s1">+</span><span class="pl-en"> x </span><span class="pl-s1">*</span><span class="pl-en"> </span><span class="pl-c1">4</span><span class="pl-en"> </span></pre></div>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">long</span> <span class="pl-en">mul12</span>(<span class="pl-smi">long</span> <span class="pl-s1">x</span>){ 
    <span class="pl-k">return</span> <span class="pl-s1">x</span> <span class="pl-c1">*</span> <span class="pl-c1">12</span>; 
}

<span class="pl-s1">leaq</span> (%<span class="pl-s1">rdi</span>, %<span class="pl-s1">rdi</span>, <span class="pl-c1">2</span>), %<span class="pl-s1">rax</span>   <span class="pl-k"># t</span> &lt;- x + 2x
<span class="pl-s1">salq</span> $<span class="pl-c1">2</span>, %<span class="pl-s1">rax</span>  <span class="pl-k"># shift</span> to left, 2bit</pre></div>
<h1>control</h1>
<p>rip: instruction pointer. in i386, it's eip.</p>
<h2>processor state</h2>
<p>information about currently executing program:</p>
<ul>
<li>temporary data</li>
<li>location of runtime stack</li>
<li>location of current code control point</li>
<li>status of recent tests (CF, SF...)</li>
</ul>
<blockquote>
<p>status register, flag register, or condition code register (CCR) is a collection of status flag bits for a processor.</p>
</blockquote>
<h3>condition code</h3>
<p>CF is for unsigned number, OF is for signed number</p>
<p>positive overflow: opsitive + opsitive = negative | negative + negative = opsitive</p>
<pre class="notranslate"><code class="notranslate">cmpq src2 src1
</code></pre>
<p>computing src1 - src2 without setting destination. Just set condition code.</p>
<pre class="notranslate"><code class="notranslate">testq src2, src1
</code></pre>
<ul>
<li>computing src1 &amp; src2 without setting destination. Just set condition code.</li>
<li>useful to have one of the operands be a mask</li>
</ul>
<h4>read condition code:</h4>
<p>SET instructions:</p>
<ul>
<li>set low-order byte of destination to 0 or 1 based on combinations of condition codes</li>
<li>does not alter remaining 7 bytes</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image.png"><img src="assets/machine-level-programming/image.png" alt="Alt text" style="max-width: 100%;"></a></p>
<p>e.g.</p>
<pre class="notranslate"><code class="notranslate">int gt(long x, long y){
  return x &gt; y;
}

asm:

cmpq %rsi, %rdi  # compare x, y
setg %al         # set when &gt;
movzbl %al, %eax # zero rest of %rax
ret
</code></pre>
<p>movzbl: move with zero extension byte to long(零扩展至32bit)<br>
由于x86-64中所有改动了32bit的指令都会将高32位清零，所以不仅仅是eax的高3个字节清零，rax的高7个字节都全部变0。</p>
<h2>Jump</h2>
<blockquote>
<p>if the condition is satisfied, jump to a destination with label.</p>
</blockquote>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">long</span> <span class="pl-en">absdiff</span>(<span class="pl-smi">long</span> <span class="pl-s1">x</span>, <span class="pl-smi">long</span> <span class="pl-s1">y</span>){
    <span class="pl-smi">long</span> <span class="pl-s1">result</span>;
    <span class="pl-k">if</span>(<span class="pl-s1">x</span> <span class="pl-c1">&gt;</span> <span class="pl-s1">y</span>) <span class="pl-s1">result</span> <span class="pl-c1">=</span> <span class="pl-s1">x</span> <span class="pl-c1">-</span> <span class="pl-s1">y</span>;
    <span class="pl-k">else</span> <span class="pl-s1">result</span> <span class="pl-c1">=</span> <span class="pl-s1">y</span> <span class="pl-c1">-</span> <span class="pl-s1">x</span>;
    <span class="pl-k">return</span> <span class="pl-s1">result</span>;
}

<span class="pl-s1">asm</span>:

    <span class="pl-s1">cmpq</span>  %<span class="pl-s1">rsi</span>, %<span class="pl-s1">rdi</span>
    <span class="pl-s1">jle</span>   .<span class="pl-c1">L4</span>
    <span class="pl-s1">movq</span>  %<span class="pl-s1">rdi</span>, %<span class="pl-s1">rax</span>
    <span class="pl-s1">subq</span>  %<span class="pl-s1">rsi</span>, %<span class="pl-s1">rax</span>
    <span class="pl-s1">ret</span>
.<span class="pl-c1">L4</span>:
    <span class="pl-s1">movq</span>  %<span class="pl-s1">rsi</span>, %<span class="pl-s1">rax</span>
    <span class="pl-s1">subq</span>  %<span class="pl-s1">rdi</span>, %<span class="pl-s1">rax</span>
    <span class="pl-s1">ret</span></pre></div>
<p>we can express it with <strong>goto</strong> code: jump to positon designated by label</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">long</span> <span class="pl-en">absdiff</span>(<span class="pl-smi">long</span> <span class="pl-s1">x</span>, <span class="pl-smi">long</span> <span class="pl-s1">y</span>){
    <span class="pl-smi">long</span> <span class="pl-s1">result</span>;
    <span class="pl-smi">int</span> <span class="pl-s1">ntest</span> <span class="pl-c1">=</span> <span class="pl-s1">x</span> &lt;= <span class="pl-s1">y</span>;
    <span class="pl-k">if</span>(<span class="pl-s1">ntest</span>) goto Else;
    <span class="pl-s1">result</span> <span class="pl-c1">=</span> <span class="pl-s1">y</span> <span class="pl-c1">-</span> <span class="pl-s1">x</span>;
    goto Done;
Else:
    <span class="pl-s1">result</span> <span class="pl-c1">=</span> <span class="pl-s1">x</span> <span class="pl-c1">-</span> <span class="pl-s1">y</span>
Done:
    <span class="pl-k">return</span> <span class="pl-s1">result</span>;
}</pre></div>
<p>jump的编码: PC相对寻址(PC-relative)</p>
<ul>
<li>将 目标指令的地址 和 紧跟在跳转指令后面的指令的地址 之间的差作为编码。也就是说，jump的编码(03) + 紧跟在jump后面的指令的地址(5) = 目标的地址(8)</li>
<li>执行PC-relative时，程序计数器的值时jump指令后面的那条指令的地址</li>
</ul>
<pre class="notranslate"><code class="notranslate">3: eb 03      jmp 8 &lt;lopp+0x8&gt;
5: 48 d1 f8   sar %rax
8: 48 85 c0   test %rax, %rax
</code></pre>
<h3>Conditional Move cmov(数据的条件转移)</h3>
<p>if computations are easy to do, do both and pick one according to the condition. do not use jump:</p>
<pre class="notranslate"><code class="notranslate">    movq  %rdi, %rax
    subq  %rsi, %rax # x-y
    movq  %rsi, %rdx
    subq  %rdi, %rdx # y-x
    cmpq  %rsi, %rdi # x:y
    cmovle %rdx, %rax # if x&lt;=y
</code></pre>
<pre class="notranslate"><code class="notranslate">v = test ? then : else
</code></pre>
<p>用条件控制转移的标准方法:</p>
<pre class="notranslate"><code class="notranslate">    if(!test)
        goto false
    v = then
    goto done
false:
    v = else  
done
</code></pre>
<p>用条件传送的方法：then 和 else都会求值</p>
<pre class="notranslate"><code class="notranslate">v = then
ve = else
t = test
if(!t) v = ve
</code></pre>
<p>不适用条件转移的情形：</p>
<ul>
<li>有副作用（全局变量）</li>
<li>可能有非法操作（解引用空指针）</li>
<li>需要大量计算</li>
</ul>
<h2>Loop</h2>
<h3>do-while</h3>
<p>count number of 1 in x(popcount)</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">long</span> <span class="pl-en">pcount</span>(<span class="pl-smi">unsigned long</span> <span class="pl-s1">x</span>){
  <span class="pl-smi">long</span> <span class="pl-s1">result</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;
  <span class="pl-k">do</span>{
    <span class="pl-s1">result</span> <span class="pl-c1">+=</span> <span class="pl-s1">x</span> <span class="pl-c1">&amp;</span> <span class="pl-c1">0x1</span>;
    <span class="pl-s1">x</span> &gt;&gt;= <span class="pl-c1">1</span>;
  }<span class="pl-k">while</span>(<span class="pl-s1">x</span>);
  <span class="pl-k">return</span> <span class="pl-s1">result</span>;
}</pre></div>
<p>goto:</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">long</span> <span class="pl-en">pcount</span>(<span class="pl-smi">unsigned long</span> <span class="pl-s1">x</span>){
  <span class="pl-smi">long</span> <span class="pl-s1">result</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;
  loop:
    <span class="pl-s1">result</span> <span class="pl-c1">+=</span> <span class="pl-s1">x</span> <span class="pl-c1">&amp;</span> <span class="pl-c1">0x1</span>;
    <span class="pl-s1">x</span> &gt;&gt;= <span class="pl-c1">1</span>;
    <span class="pl-k">if</span>(<span class="pl-s1">x</span>) goto loop;
  <span class="pl-k">return</span> <span class="pl-s1">result</span>;
}</pre></div>
<p>asm: "jump to middle"</p>
<pre class="notranslate"><code class="notranslate">  movl $0, %eax  # result = 0;
.L2:             # loop:
  movq %rdi, %rdx
  andl $1, %edx  # t = x &amp; 1
  addq %rdx, %rax # result += t
  shrq %rdi      # x &gt;&gt;= 1
  jne .L2        # if(x) goto loop
  rep; ret
</code></pre>
<h3>while</h3>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">long</span> <span class="pl-en">pcount</span>(<span class="pl-smi">unsigned long</span> <span class="pl-s1">x</span>){
  <span class="pl-smi">long</span> <span class="pl-s1">result</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;
  <span class="pl-k">while</span>(<span class="pl-s1">x</span>){
    <span class="pl-s1">result</span> <span class="pl-c1">+=</span> <span class="pl-s1">x</span> <span class="pl-c1">&amp;</span> <span class="pl-c1">0x1</span>;
    <span class="pl-s1">x</span> &gt;&gt;= <span class="pl-c1">1</span>;
  }
  <span class="pl-k">return</span> <span class="pl-s1">result</span>;
}</pre></div>
<p>goto:</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">long</span> <span class="pl-en">pcount</span>(<span class="pl-smi">unsigned long</span> <span class="pl-s1">x</span>){
  <span class="pl-smi">long</span> <span class="pl-s1">result</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;
  goto test;  <span class="pl-c1">&lt;</span><span class="pl-c1">--</span><span class="pl-c1">--</span>
  <span class="pl-s1">loop</span>:
    <span class="pl-s1">result</span> <span class="pl-c1">+=</span> <span class="pl-s1">x</span> <span class="pl-c1">&amp;</span> <span class="pl-c1">0x1</span>;
    <span class="pl-s1">x</span> &gt;&gt;= <span class="pl-c1">1</span>;
  test:       <span class="pl-c1">&lt;</span><span class="pl-c1">--</span><span class="pl-c1">--</span>
    <span class="pl-en">if</span>(<span class="pl-s1">x</span>) <span class="pl-s1">goto</span> <span class="pl-s1">loop</span>;
  <span class="pl-k">return</span> <span class="pl-s1">result</span>;
}</pre></div>
<p>another version: use initial-test + do-while:</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">long</span> <span class="pl-en">pcount</span>(<span class="pl-smi">unsigned long</span> <span class="pl-s1">x</span>){
  <span class="pl-smi">long</span> <span class="pl-s1">result</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;
  <span class="pl-k">if</span>(!<span class="pl-s1">x</span>) goto done;  <span class="pl-c1">&lt;</span><span class="pl-c1">--</span><span class="pl-c1">--</span>
  <span class="pl-s1">loop</span>:
    <span class="pl-s1">result</span> <span class="pl-c1">+=</span> <span class="pl-s1">x</span> <span class="pl-c1">&amp;</span> <span class="pl-c1">0x1</span>;
    <span class="pl-s1">x</span> &gt;&gt;= <span class="pl-c1">1</span>;
    <span class="pl-k">if</span>(<span class="pl-s1">x</span>) goto loop;
  done:              <span class="pl-c1">&lt;</span><span class="pl-c1">--</span><span class="pl-c1">--</span>
    <span class="pl-s1">return</span> <span class="pl-s1">result</span>;
}</pre></div>
<h3>for</h3>
<pre class="notranslate"><code class="notranslate">for(init; test; update)
    body
          |
          |
         \ /
          '
init;
while(test){
    body
    update
}
</code></pre>
<p>In -O1, Initial test can be optimized away:<br>
<a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image-1.png"><img src="assets/machine-level-programming/image-1.png" alt="Alt text" style="max-width: 100%;"></a></p>
<h2>switch</h2>
<p>jump table</p>
<p><a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image-2.png"><img src="assets/machine-level-programming/image-2.png" alt="Alt text" style="max-width: 100%;"></a><br>
<a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image-4.png"><img src="assets/machine-level-programming/image-4.png" alt="Alt text" style="max-width: 100%;"></a></p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">long</span> <span class="pl-en">switch</span>(<span class="pl-smi">long</span> <span class="pl-s1">x</span>, <span class="pl-smi">long</span> <span class="pl-s1">y</span>, <span class="pl-smi">long</span> <span class="pl-s1">z</span>){
  <span class="pl-smi">long</span> <span class="pl-s1">w</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span>;
  <span class="pl-k">switch</span>(<span class="pl-s1">x</span>){  <span class="pl-c">// 1~6, no 4</span>
    <span class="pl-k">case</span> <span class="pl-c1">1</span>: <span class="pl-k">break</span>;
    <span class="pl-k">case</span> <span class="pl-c1">2</span>: <span class="pl-s1">w</span> <span class="pl-c1">=</span> <span class="pl-s1">y</span>/<span class="pl-s1">z</span>;
    <span class="pl-k">case</span> <span class="pl-c1">3</span>: <span class="pl-s1">w</span> <span class="pl-c1">+=</span> <span class="pl-s1">z</span>; <span class="pl-k">break</span>;
    <span class="pl-k">case</span> <span class="pl-c1">5</span>: 
    <span class="pl-k">case</span> <span class="pl-c1">6</span>: <span class="pl-k">break</span>;
    <span class="pl-k">default</span>;
  }
  <span class="pl-k">return</span> <span class="pl-s1">w</span>;
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image-3.png"><img src="assets/machine-level-programming/image-3.png" alt="Alt text" style="max-width: 100%;"></a></p>
<ul>
<li>case 4 is treated as default case(.L8).</li>
<li>case 5 6 is using the same label .L7, because there is no break in case 5.</li>
</ul>
<p>asm</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">switch:</span>
<span class="pl-en">  </span><span class="pl-k">movq</span><span class="pl-en"> %</span><span class="pl-v">rdx</span><span class="pl-s1">,</span><span class="pl-en"> %</span><span class="pl-v">rcx</span>
<span class="pl-en">  cmpq</span> <span class="pl-c1">$</span><span class="pl-c1">6</span><span class="pl-s1">,</span><span class="pl-en"> %</span><span class="pl-v">rdi</span><span class="pl-en">         # x:</span><span class="pl-c1">6</span>
<span class="pl-en">  </span><span class="pl-k">ja</span><span class="pl-en">   .L8              # default</span>
<span class="pl-en">  </span><span class="pl-k">jmp</span><span class="pl-en">  </span><span class="pl-s1">*</span><span class="pl-en">.L4(</span><span class="pl-s1">,</span><span class="pl-en"> %</span><span class="pl-v">rdi</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">8</span><span class="pl-en">)  # goto </span><span class="pl-s1">*</span><span class="pl-en">JTab</span><span class="pl-s1">[</span><span class="pl-en">x</span><span class="pl-s1">]</span></pre></div>
<p><code class="notranslate">ja</code>: jump above. the number is treated as <strong>unsigned</strong>.</p>
<ul>
<li>if x &gt; 6, it will jump;</li>
<li>if x &lt; 0, the unsigned x will be a large positive number larger than 6, it will jump too.</li>
</ul>
<p>n</p>
<pre class="notranslate"><code class="notranslate">.L5:
  movq %rsi, %rax
  cqto
  idivq %rcx      # y/z
  jmp .L6         # goto merge
.L9:
  movl $1, %eax   # w = 1
.L6:
  addq %rcx, %rax # w += z
  ret
</code></pre>
<h1>procedure</h1>
<h2>calling conventions</h2>
<h3>passing control</h3>
<p>ABI(application binary interface)应用程序二进制接口</p>
<p><a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image-5.png"><img src="assets/machine-level-programming/image-5.png" alt="Alt text" style="max-width: 100%;"></a></p>
<p>stack:</p>
<ul>
<li>the top is in the bottom.</li>
<li>push, <code class="notranslate">stack pointer--</code></li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image-6.png"><img src="assets/machine-level-programming/image-6.png" alt="Alt text" style="max-width: 100%;"></a></p>
<p><code class="notranslate">pushq SRC</code>:</p>
<ul>
<li>fetch operand at SRC</li>
<li>%rsp -= 8</li>
<li>write operand at address given by %rsp</li>
</ul>
<p><code class="notranslate">popq DEST</code>:</p>
<ul>
<li>read value at address given by %rsp</li>
<li>%rsp += 8</li>
<li>store value at DEST(must be a register)</li>
</ul>
<p>Procedure control flow: use <strong>stack</strong> to support procedure call and return</p>
<ul>
<li>procedure call: call label
<ul>
<li><strong>push</strong> return address into stack</li>
<li>jump to label</li>
</ul>
</li>
<li>return address:
<ul>
<li>address of the <strong>next</strong> instruction after call</li>
</ul>
</li>
<li>procedure return: ret
<ul>
<li><strong>pop</strong> address from stack</li>
<li>jump to address</li>
</ul>
</li>
</ul>
<p><code class="notranslate">callq 400550 &lt;mul2&gt;</code>: push the return address into stack and set the PC to the new value.</p>
<p><code class="notranslate">retq</code>: pop the address off the stack(rsp++), and set the PC to that address.</p>
<h3>passing data</h3>
<p>argument type: integer, pointer</p>
<p><a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image-7.png"><img src="assets/machine-level-programming/image-7.png" alt="Alt text" style="max-width: 100%;"></a></p>
<p>stack frame:</p>
<p>contents:</p>
<ul>
<li>return information</li>
<li>local storage</li>
<li>temporary space</li>
</ul>
<p>management:</p>
<ul>
<li>space <strong>allocated</strong> when enter procedure
<ul>
<li>set-up code</li>
<li>includes push by <code class="notranslate">call</code> instruction</li>
</ul>
</li>
<li><strong>deallocated</strong> when return
<ul>
<li>finish code</li>
<li>includes pop by <code class="notranslate">ret</code> instruction</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image-8.png"><img src="assets/machine-level-programming/image-8.png" alt="Alt text" style="max-width: 100%;"></a></p>
<ul>
<li>Current stack frame
<ul>
<li>argument build: parameters for function about to call</li>
<li>local variables</li>
<li>saved register content</li>
<li>old frame pointer(optional)</li>
</ul>
</li>
<li>Caller Stack Frame
<ul>
<li>return address(pushed by <code class="notranslate">call</code>)</li>
<li>arguments for this call</li>
</ul>
</li>
</ul>
<div class="highlight highlight-source-c"><pre class="notranslate">%<span class="pl-s1">rdi</span>: <span class="pl-s1">argument</span> <span class="pl-s1">p</span>
%<span class="pl-s1">rsi</span>: <span class="pl-s1">argument</span> <span class="pl-s1">val</span>, <span class="pl-s1">y</span>
%<span class="pl-s1">rax</span>: <span class="pl-s1">x</span>, <span class="pl-s1">return</span> <span class="pl-s1">value</span>

<span class="pl-smi">long</span> <span class="pl-en">incr</span>(<span class="pl-smi">long</span> <span class="pl-c1">*</span><span class="pl-s1">p</span>, <span class="pl-smi">long</span> <span class="pl-s1">val</span>){
  <span class="pl-smi">long</span> <span class="pl-s1">x</span> <span class="pl-c1">=</span> <span class="pl-c1">*</span><span class="pl-s1">p</span>;
  <span class="pl-smi">long</span> <span class="pl-s1">y</span> <span class="pl-c1">=</span> <span class="pl-s1">x</span> <span class="pl-c1">+</span> <span class="pl-s1">val</span>;
  <span class="pl-k">return</span> <span class="pl-s1">x</span>;
}

incr:
  <span class="pl-en">movq</span>  (%<span class="pl-s1">rdi</span>)  %<span class="pl-s1">rax</span>
  <span class="pl-s1">addq</span>  %<span class="pl-s1">rax</span>,  %<span class="pl-s1">rsi</span>
  <span class="pl-s1">movq</span>  %<span class="pl-s1">rsi</span>,  (%<span class="pl-smi">rdi</span>)
  <span class="pl-s1">ret</span></pre></div>
<pre class="notranslate"><code class="notranslate">long call_incr(){
  long v1 = 15213;
  long v2 = incr(&amp;v1, 3000);
  return v1 + v2;
}

call_incr:
  subq  $16, %rsp       # allocate
  movq  $15213, 8(%rsp) # push in stack
  movl  $3000, %esi
  leaq  8(%rsp), %rdi   # 把15213的地址传入rdi
  call  incr            # 调用函数
  addq  8(%rsp), %rax
  addq  $16, %rsp       # deallocate
  ret
</code></pre>
<p>register saving conventions</p>
<ul>
<li>caller saved: caller saves temporary values in its frame before the call</li>
<li>callee saved: callee saves temporary values in its frame before using, and restores them before returning to caller</li>
</ul>
<h2>recursion</h2>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/* recursive popcount */</span>
<span class="pl-smi">long</span> <span class="pl-en">pcount_r</span>(<span class="pl-smi">unsigned long</span> <span class="pl-s1">x</span>){
  <span class="pl-k">if</span>(<span class="pl-s1">x</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
  <span class="pl-k">else</span>
    <span class="pl-k">return</span> (<span class="pl-s1">x</span> <span class="pl-c1">&amp;</span> <span class="pl-c1">1</span>) <span class="pl-c1">+</span> <span class="pl-en">pcount_r</span>(<span class="pl-s1">x</span> &gt;&gt; <span class="pl-c1">1</span>);
}

rdi: <span class="pl-s1">x</span>
rax: <span class="pl-k">return</span> <span class="pl-s1">value</span>

pcount_r:
  <span class="pl-s1">movl</span>    $<span class="pl-c1">0</span>, %<span class="pl-s1">eax</span>   <span class="pl-k"># assume</span> x is 0 and set the return value(eax) 0
  <span class="pl-s1">testq</span>   %<span class="pl-s1">rdi</span>, %<span class="pl-s1">rdi</span> <span class="pl-k"># x</span>:0
  <span class="pl-s1">je</span>      .<span class="pl-c1">L6</span>        <span class="pl-k"># jump</span> if equal
  <span class="pl-s1">pushq</span>   %<span class="pl-s1">rbx</span>       # <span class="pl-s1">暂存rbx内的值以便之后复原</span>
  <span class="pl-s1">movq</span>    %<span class="pl-s1">rdi</span>, %<span class="pl-s1">rbx</span> # <span class="pl-s1">把x放到rbx</span>
  <span class="pl-s1">andl</span>    $<span class="pl-c1">1</span>, %<span class="pl-s1">ebx</span>   <span class="pl-k"># x</span> &amp; 1
  <span class="pl-s1">shrq</span>    %<span class="pl-s1">rdi</span>       <span class="pl-k"># x</span> &gt;&gt; 1
  <span class="pl-smi">call</span>    <span class="pl-s1">pcount_r</span>
  <span class="pl-s1">addq</span>    %<span class="pl-s1">rbx</span>, %<span class="pl-s1">rax</span> <span class="pl-k"># rax</span>: 递归结果
  <span class="pl-s1">popq</span>    %<span class="pl-s1">rbx</span>       # <span class="pl-s1">复原rbx之前的值</span>
.<span class="pl-c1">L6</span>:
  <span class="pl-s1">rep</span>; <span class="pl-smi">ret</span></pre></div>
<ul>
<li>stack frame: each function call has private storage
<ul>
<li>saved registers &amp; local variables</li>
<li>saved return pointer</li>
</ul>
</li>
<li>register saving conventions prevent one function call from corrupting other's data</li>
<li>stack discipline follows call/return pattern
<ul>
<li>if P calls Q, then Q returns before P</li>
</ul>
</li>
</ul>
<h1>Data</h1>
<h2>array</h2>
<h3>array accessing</h3>
<p>e.g.</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">typedef</span> <span class="pl-smi">int</span> <span class="pl-smi">zip_dig</span>[<span class="pl-c1">5</span>]
<span class="pl-smi">int</span> <span class="pl-en">get_digit</span>(<span class="pl-smi">zip_dig</span> <span class="pl-s1">z</span>, <span class="pl-smi">int</span> <span class="pl-s1">digit</span>){
  <span class="pl-k">return</span> <span class="pl-s1">z</span>[<span class="pl-s1">digit</span>];
}</pre></div>
<div class="highlight highlight-source-shell"><pre class="notranslate">%rdi = z                  <span class="pl-c"><span class="pl-c">#</span> rdi: starting address (z)</span>
%rsi = digit              <span class="pl-c"><span class="pl-c">#</span> rsi: array index (digit)</span>
movl(%rdi, %rsi, 4), %eax <span class="pl-c"><span class="pl-c">#</span> eax: z[digit], digit = z + 4*digit</span></pre></div>
<h3>array loop</h3>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">void</span> <span class="pl-en">incr</span>(<span class="pl-smi">zip_dig</span> <span class="pl-s1">z</span>){
  <span class="pl-smi">size_t</span> <span class="pl-s1">i</span>;
  <span class="pl-k">for</span>(<span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">LEN</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span>){
    <span class="pl-s1">z</span>[<span class="pl-s1">i</span>]<span class="pl-c1">++</span>;
  }
}</pre></div>
<div class="highlight highlight-source-shell"><pre class="notranslate">  movl  <span class="pl-smi">$0</span>, %eax  <span class="pl-c"><span class="pl-c">#</span> i = 0</span>
  jmp   .L3       <span class="pl-c"><span class="pl-c">#</span> goto middle</span>
.L4:              <span class="pl-c"><span class="pl-c">#</span> loop</span>
  addl  <span class="pl-smi">$1</span>, (%rdi, %rax, 4)   <span class="pl-c"><span class="pl-c">#</span> z[i]++</span>
  addq  <span class="pl-smi">$1</span>, %rax  <span class="pl-c"><span class="pl-c">#</span> i++</span>
.L3:              <span class="pl-c"><span class="pl-c">#</span> middle</span>
  cmpq  <span class="pl-smi">$4</span>, %rax  <span class="pl-c"><span class="pl-c">#</span> i:4</span>
  jbe   .L4       <span class="pl-c"><span class="pl-c">#</span> if &lt;=, goto loop</span>
  ret</pre></div>
<h2>multidimensional(nested) arrays</h2>
<p>arrangement: row-major ordering</p>
<p><code class="notranslate">int A[R][C]</code>;</p>
<pre class="notranslate"><code class="notranslate"> A  ... A    A  ... A  ...  A  ... A
[0]    [0]  [1]    [1]    [R-1]  [R-1]
[0]   [C-1] [0]   [C-1]    [0]   [C-1]
</code></pre>
<p>every column's starting address: <code class="notranslate">A + i * C * ele_size</code></p>
<p><a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image-9.png"><img src="assets/machine-level-programming/image-9.png" alt="alt text" style="max-width: 100%;"></a></p>
<h3>multidimensional array accessing</h3>
<ol>
<li>get the ith column</li>
</ol>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">#define</span> <span class="pl-c1">PCOUNT</span> 4
<span class="pl-smi">zip_dig</span> <span class="pl-s1">pgh</span>[<span class="pl-c1">PCOUNT</span>] <span class="pl-c1">=</span>
 {{<span class="pl-c1">1</span>, <span class="pl-c1">5</span>, <span class="pl-c1">2</span>, <span class="pl-c1">0</span>, <span class="pl-c1">6</span>},
 {<span class="pl-c1">1</span>, <span class="pl-c1">5</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span> },
 {<span class="pl-c1">1</span>, <span class="pl-c1">5</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">7</span> },
 {<span class="pl-c1">1</span>, <span class="pl-c1">5</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span> }}; 

<span class="pl-smi">int</span> <span class="pl-c1">*</span><span class="pl-en">get_pgh_zip</span>(<span class="pl-smi">int</span> <span class="pl-s1">index</span>)
{
 <span class="pl-k">return</span> <span class="pl-s1">pgh</span>[<span class="pl-s1">index</span>];
}</pre></div>
<div class="highlight highlight-source-c"><pre class="notranslate"># %<span class="pl-s1">rdi</span> <span class="pl-c1">=</span> <span class="pl-s1">index</span>
<span class="pl-s1">leaq</span> (%<span class="pl-s1">rdi</span>,%<span class="pl-s1">rdi</span>,<span class="pl-c1">4</span>), %<span class="pl-s1">rax</span>      # <span class="pl-c1">5</span> <span class="pl-c1">*</span> <span class="pl-s1">index</span>
<span class="pl-smi">leaq</span> <span class="pl-en">pgh</span>(,%<span class="pl-smi">rax</span>,<span class="pl-c1">4</span>),%<span class="pl-s1">rax</span>        <span class="pl-k"># pgh</span> + (20 * index)</pre></div>
<ol start="2">
<li></li>
</ol>
<p><a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image-10.png"><img src="assets/machine-level-programming/image-10.png" alt="alt text" style="max-width: 100%;"></a></p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">int</span> <span class="pl-en">get_pgh_digit</span> (<span class="pl-smi">int</span> <span class="pl-s1">index</span>, <span class="pl-smi">int</span> <span class="pl-s1">dig</span>)
{
 <span class="pl-k">return</span> <span class="pl-s1">pgh</span>[<span class="pl-s1">index</span>][<span class="pl-s1">dig</span>];
} </pre></div>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-s1">leaq</span> (%<span class="pl-s1">rdi</span>,%<span class="pl-s1">rdi</span>,<span class="pl-c1">4</span>), %<span class="pl-s1">rax</span>      # <span class="pl-c1">5</span><span class="pl-c1">*</span><span class="pl-s1">index</span>
<span class="pl-s1">addl</span> %<span class="pl-s1">rax</span>, %<span class="pl-s1">rsi</span>               # <span class="pl-c1">5</span><span class="pl-c1">*</span><span class="pl-s1">index</span><span class="pl-c1">+</span><span class="pl-s1">dig</span>
<span class="pl-smi">movl</span> <span class="pl-en">pgh</span>(,%<span class="pl-smi">rsi</span>,<span class="pl-c1">4</span>), %<span class="pl-s1">eax</span>       <span class="pl-k"># M</span>[pgh + 4*(5*index+dig)]</pre></div>
<h3>multi-level array</h3>
<p><a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image-11.png"><img src="assets/machine-level-programming/image-11.png" alt="alt text" style="max-width: 100%;"></a></p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">zip_dig</span> <span class="pl-s1">cmu</span> <span class="pl-c1">=</span> { <span class="pl-c1">1</span>, <span class="pl-c1">5</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span> };
<span class="pl-smi">zip_dig</span> <span class="pl-s1">mit</span> <span class="pl-c1">=</span> { <span class="pl-c1">0</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">9</span> };
<span class="pl-smi">zip_dig</span> <span class="pl-s1">ucb</span> <span class="pl-c1">=</span> { <span class="pl-c1">9</span>, <span class="pl-c1">4</span>, <span class="pl-c1">7</span>, <span class="pl-c1">2</span>, <span class="pl-c1">0</span> };
<span class="pl-k">#define</span> <span class="pl-c1">UCOUNT</span> 3
<span class="pl-smi">int</span> <span class="pl-c1">*</span><span class="pl-s1">univ</span>[<span class="pl-c1">UCOUNT</span>] <span class="pl-c1">=</span> {<span class="pl-s1">mit</span>, <span class="pl-s1">cmu</span>, <span class="pl-s1">ucb</span>}; 

<span class="pl-smi">int</span> <span class="pl-en">get_univ_digit</span>
 (<span class="pl-smi">size_t</span> <span class="pl-s1">index</span>, <span class="pl-smi">size_t</span> <span class="pl-s1">digit</span>)
{
 <span class="pl-k">return</span> <span class="pl-s1">univ</span>[<span class="pl-s1">index</span>][<span class="pl-s1">digit</span>];
} </pre></div>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-s1">salq</span>   $<span class="pl-c1">2</span>, %<span class="pl-s1">rsi</span>             # <span class="pl-c1">4</span><span class="pl-c1">*</span><span class="pl-s1">digit</span>
<span class="pl-smi">addq</span>   <span class="pl-en">univ</span>(,%<span class="pl-smi">rdi</span>,<span class="pl-c1">8</span>), %<span class="pl-s1">rsi</span>  <span class="pl-k"># p</span> = univ[index] + 4*digit
<span class="pl-s1">movl</span>   (%<span class="pl-smi">rsi</span>), %<span class="pl-s1">eax</span>         <span class="pl-k"># return</span> <span class="pl-c1">*</span><span class="pl-s1">p</span>
<span class="pl-s1">ret</span></pre></div>
<p>Element	access: <code class="notranslate">Mem[Mem[univ+8*index]+4*digit] </code><br>
do 2 memory	reads</p>
<ul>
<li>
<p>First	get	pointer	to row array</p>
</li>
<li>
<p>Then access element	within array</p>
</li>
<li>
<p>multi-level array has two memory access</p>
</li>
<li>
<p>nested array has one memory access</p>
</li>
</ul>
<h3>nxn matrix access</h3>
<p>because n is a unknown number, so imulq instr is used.</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">int</span> <span class="pl-en">var_ele</span>(<span class="pl-smi">size_t</span> <span class="pl-s1">n</span>, <span class="pl-smi">int</span> <span class="pl-s1">a</span>[<span class="pl-s1">n</span>][<span class="pl-s1">n</span>], <span class="pl-smi">size_t</span> <span class="pl-s1">i</span>, <span class="pl-smi">size_t</span> <span class="pl-s1">j</span>)
{
 <span class="pl-k">return</span> <span class="pl-s1">a</span>[<span class="pl-s1">i</span>][<span class="pl-s1">j</span>];
}

<span class="pl-k"># n</span> in %rdi, a in %rsi, i in %rdx, j in %rcx
<span class="pl-s1">imulq</span> %<span class="pl-s1">rdx</span>, %<span class="pl-s1">rdi</span>            <span class="pl-k"># n</span>*i
<span class="pl-s1">leaq</span> (%<span class="pl-s1">rsi</span>,%<span class="pl-s1">rdi</span>,<span class="pl-c1">4</span>), %<span class="pl-s1">rax</span>    <span class="pl-k"># a</span> + 4*n*i
<span class="pl-s1">movl</span> (%<span class="pl-s1">rax</span>,%<span class="pl-s1">rcx</span>,<span class="pl-c1">4</span>), %<span class="pl-s1">eax</span>    <span class="pl-k"># a</span> + 4*n*i + 4*j
<span class="pl-smi">ret</span>   </pre></div>
<h2>structures</h2>
<p><a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image-12.png"><img src="assets/machine-level-programming/image-12.png" alt="alt text" style="max-width: 100%;"></a></p>
<ul>
<li>a block of memory for every element</li>
<li>memory ordered according to declaration</li>
<li>Compiler determines overall	size +	positions	of fields</li>
</ul>
<p>linked list:</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">struct</span> <span class="pl-smi">rec</span> {
 <span class="pl-smi">int</span> <span class="pl-c1">a</span>[<span class="pl-c1">4</span>];
 <span class="pl-smi">int</span> <span class="pl-c1">i</span>;
 <span class="pl-k">struct</span> <span class="pl-smi">rec</span> <span class="pl-c1">*</span><span class="pl-c1">next</span>;
}; 
<span class="pl-smi">void</span> <span class="pl-en">set_val</span>(<span class="pl-k">struct</span> <span class="pl-smi">rec</span> <span class="pl-c1">*</span><span class="pl-s1">r</span>, <span class="pl-smi">int</span> <span class="pl-s1">val</span>)
{
  <span class="pl-k">while</span> (<span class="pl-s1">r</span>) {
    <span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-s1">r</span><span class="pl-c1">-&gt;</span><span class="pl-c1">i</span>;
    <span class="pl-s1">r</span><span class="pl-c1">-&gt;</span><span class="pl-c1">a</span>[<span class="pl-s1">i</span>] <span class="pl-c1">=</span> <span class="pl-s1">val</span>;
    <span class="pl-s1">r</span> <span class="pl-c1">=</span> <span class="pl-s1">r</span><span class="pl-c1">-&gt;</span><span class="pl-c1">next</span>;
  }
} </pre></div>
<pre class="notranslate"><code class="notranslate">rdi: r
rsi: val
.L11:                       # loop:
  movslq 16(%rdi), %rax     # i = M[r+16]
  movl %esi, (%rdi,%rax,4)  # M[r+4*i] = val
  movq 24(%rdi), %rdi       # r = M[r+24]
  testq %rdi, %rdi          # Test r
  jne .L11                  # if !=0  goto loop
</code></pre>
<p>Alignment of struct:</p>
<ul>
<li>the largest data type requires K bytes, then address must be multiple of K</li>
<li></li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image-13.png"><img src="assets/machine-level-programming/image-13.png" alt="alt text" style="max-width: 100%;"></a></p>
<p>save spaces in alignment: put large data types first<br>
<a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image-14.png"><img src="assets/machine-level-programming/image-14.png" alt="alt text" style="max-width: 100%;"></a></p>
<h2>pointer</h2>
<p>the pointer just be allocated the memory of <strong>this pointer(8 bytes)</strong>, not its type that is point to.</p>
<div class="highlight highlight-source-c"><pre class="notranslate">                <span class="pl-smi">size</span> <span class="pl-s1">of</span> <span class="pl-s1">it</span>
<span class="pl-smi">int</span> <span class="pl-c1">A1</span>[<span class="pl-c1">3</span>]           <span class="pl-c1">12</span>
<span class="pl-smi">int</span> <span class="pl-c1">*</span><span class="pl-c1">A2</span>[<span class="pl-c1">3</span>]          <span class="pl-c1">8</span></pre></div>
<p>Cmp: compiles Y/N<br>
Bad: possible bad pointer reference Y/N<br>
Size: value returned by sizeof</p>
<p><code class="notranslate">int A1[3]</code>: 数组，元素为int类型<br>
<code class="notranslate">int *A2[3]</code>: 数组，元素为<code class="notranslate">int*</code>类型（指向int类型的指针）<br>
<code class="notranslate">int (*A3)[3]</code>: 指针，指向数组<br>
<code class="notranslate">int (*A4[3])</code>: 数组，元素为<code class="notranslate">int*</code>类型（指向int类型的指针）。和A2一模一样</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">int</span> <span class="pl-c1">A1</span>[<span class="pl-c1">3</span>] <span class="pl-c1">=</span> {<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>};

<span class="pl-smi">int</span> <span class="pl-s1">a</span>, <span class="pl-s1">b</span>, <span class="pl-s1">c</span>;
<span class="pl-smi">int</span> <span class="pl-c1">*</span><span class="pl-c1">A2</span>[<span class="pl-c1">3</span>] <span class="pl-c1">=</span> {<span class="pl-c1">&amp;</span><span class="pl-s1">a</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">b</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">c</span>};

<span class="pl-smi">int</span> <span class="pl-s1">arr</span>[<span class="pl-c1">3</span>] <span class="pl-c1">=</span> {<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>};
<span class="pl-smi">int</span> (<span class="pl-c1">*</span><span class="pl-c1">A3</span>)[<span class="pl-c1">3</span>] <span class="pl-c1">=</span> <span class="pl-c1">&amp;</span><span class="pl-s1">arr</span>;  <span class="pl-c">// A3 是指向 arr 数组的指针</span>

<span class="pl-smi">int</span> <span class="pl-s1">a</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span>, <span class="pl-s1">b</span> <span class="pl-c1">=</span> <span class="pl-c1">2</span>, <span class="pl-s1">c</span> <span class="pl-c1">=</span> <span class="pl-c1">3</span>;
<span class="pl-smi">int</span> <span class="pl-c1">*</span><span class="pl-c1">A4</span>[<span class="pl-c1">3</span>] <span class="pl-c1">=</span> {<span class="pl-c1">&amp;</span><span class="pl-s1">a</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">b</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">c</span>};  <span class="pl-c">// 和 A2 的效果类似</span></pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image-16.png"><img src="assets/machine-level-programming/image-16.png" alt="alt text" style="max-width: 100%;"></a></p>
<p><code class="notranslate">int A1[3][5]</code>: 二维数组，元素是int类型<br>
<code class="notranslate">int *A2[3][5]</code>: 二维数组，元素为<code class="notranslate">int*</code>类型（指向int类型的指针）<br>
<code class="notranslate">int (*A3)[3][5]</code>: 指针，指向 3x5 大小二维数组。<br>
<code class="notranslate">int *(A4[3][5])</code>: 与 A2 等价<br>
<code class="notranslate">int (*A5[3])[5]</code>: 数组，元素是指向int类型数组的指针。</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">int</span> <span class="pl-c1">A1</span>[<span class="pl-c1">3</span>][<span class="pl-c1">5</span>] <span class="pl-c1">=</span> {
    {<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>},
    {<span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>},
    {<span class="pl-c1">11</span>, <span class="pl-c1">12</span>, <span class="pl-c1">13</span>, <span class="pl-c1">14</span>, <span class="pl-c1">15</span>}
};

<span class="pl-smi">int</span> <span class="pl-s1">a</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span>, <span class="pl-s1">b</span> <span class="pl-c1">=</span> <span class="pl-c1">2</span>, <span class="pl-s1">c</span> <span class="pl-c1">=</span> <span class="pl-c1">3</span>;
<span class="pl-smi">int</span> <span class="pl-c1">*</span><span class="pl-c1">A2</span>[<span class="pl-c1">3</span>][<span class="pl-c1">5</span>] <span class="pl-c1">=</span> {
    {<span class="pl-c1">&amp;</span><span class="pl-s1">a</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">b</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">c</span>, <span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>},
    {<span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>},
    {<span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>}
};

<span class="pl-smi">int</span> (<span class="pl-c1">*</span><span class="pl-c1">A3</span>)[<span class="pl-c1">3</span>][<span class="pl-c1">5</span>] <span class="pl-c1">=</span> <span class="pl-c1">&amp;</span><span class="pl-c1">A1</span>; 

<span class="pl-smi">int</span> <span class="pl-s1">a</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span>;
<span class="pl-smi">int</span> <span class="pl-c1">*</span>(<span class="pl-c1">A4</span>[<span class="pl-c1">3</span>][<span class="pl-c1">5</span>]) <span class="pl-c1">=</span> {
    {<span class="pl-c1">&amp;</span><span class="pl-s1">a</span>, <span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>},
    {<span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>},
    {<span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>, <span class="pl-s1">nullptr</span>}
};

<span class="pl-smi">int</span> <span class="pl-s1">arr1</span>[<span class="pl-c1">5</span>] <span class="pl-c1">=</span> {<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>};
<span class="pl-smi">int</span> <span class="pl-s1">arr2</span>[<span class="pl-c1">5</span>] <span class="pl-c1">=</span> {<span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>, <span class="pl-c1">10</span>};
<span class="pl-smi">int</span> <span class="pl-s1">arr3</span>[<span class="pl-c1">5</span>] <span class="pl-c1">=</span> {<span class="pl-c1">11</span>, <span class="pl-c1">12</span>, <span class="pl-c1">13</span>, <span class="pl-c1">14</span>, <span class="pl-c1">15</span>};

<span class="pl-smi">int</span> (<span class="pl-c1">*</span><span class="pl-c1">A5</span>[<span class="pl-c1">3</span>])[<span class="pl-c1">5</span>] <span class="pl-c1">=</span> {<span class="pl-c1">&amp;</span><span class="pl-s1">arr1</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">arr2</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">arr3</span>}; </pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image-17.png"><img src="assets/machine-level-programming/image-17.png" alt="alt text" style="max-width: 100%;"></a><br>
<a target="_blank" rel="noopener noreferrer" href="assets/machine-level-programming/image-18.png"><img src="assets/machine-level-programming/image-18.png" alt="alt text" style="max-width: 100%;"></a></p></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://flippyside.github.io/akosus.github.io">Blog Title</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","flippyside/akosus.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script>MathJax = {tex: {inlineMath: [["$", "$"]]}};</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</html>
